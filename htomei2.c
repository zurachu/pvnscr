
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <piece.h>

#include "htomei2.h"

/*******************************************************************
* 関数名：hanToumeiAll
*  仮想画面全体に半透明処理を行います。
*-------------------------------------------------------------------
* 引数
*  type --- 半透明処理タイプ
*           1:薄く1 ( 0,1→0 : 2,3→1 )
*           2:薄く2 ( 0,1→0 : 2→1 : 3 →2 )
*           3:濃く1 ( 0,1→2 : 2,3→3 )
*           4:濃く2 ( 0→1 : 1→2 : 2,3→3 )
*           5:反転1 ( 0→3 : 1→2 : 2→1 : 3→0 )
*           6:反転2 ( 0,1,2→3 : 3→0 )
*           7:反転3 ( 0→3 : 1,2,3→0 )
*-------------------------------------------------------------------
* 戻り値
*  なし
*-------------------------------------------------------------------
* 備考
*  仮想画面全体の処理専用
*******************************************************************/
void hanToumeiAll( unsigned char type )
{
	unsigned long *p=(unsigned long *)pceLCDSetBuffer(INVALIDPTR);
	unsigned long *pe=p+128*88/4;
	
	switch (type) {
		case 1://薄く1( 0,1→0 : 2,3→1 )
			for (;p<pe;p+=1) {
				*p=(*p&0x02020202)>>1;
			}
			break;
		case 2://薄く2( 0,1→0 : 2→1 : 3 →2 )
			for (;p<pe;p+=1) {
				*p=(*p^0x01010101)&((*p&0x01010101)<<1|(*p&0x02020202)>>1);
			}
			break;
		case 3://濃く1( 0,1→2 : 2,3→3 )
			for (;p<pe;p+=1) {
				*p=0x02020202|((*p&0x02020202)>>1);
			}
			break;
		case 4://濃く2( 0→1 : 1→2 : 2,3→3 )
			for (;p<pe;p+=1) {
				*p=(*p^0x01010101)|((*p&0x01010101)<<1)|((*p&0x02020202)>>1);
			}
			break;
		case 5://反転1( 0→3 : 1→2 : 2→1 : 3→0 )
			for (;p<pe;p+=1) {
				*p^=0x03030303;
			}
			break;
		case 6://反転2( 0,1,2→3 : 3→0 )
			for (;p<pe;p+=1) {
				*p=(*p&0x01010101&(*p&0x02020202)>>1)^0x01010101;
				*p|=*p<<1;
			}
			break;
		case 7://反転3( 0→3 : 1,2,3→0 )
			for (;p<pe;p+=1) {
				*p=((*p&0x01010101)|((*p&0x02020202)>>1))^0x01010101;
				*p|=*p<<1;
			}
			break;
	}
}

/*******************************************************************
* 関数名：hanToumei
*  仮想画面の一部に半透明処理を行います。
*-------------------------------------------------------------------
* 引数
*  type --- 半透明処理タイプ
*           1:薄く1 ( 0,1→0 : 2,3→1 )
*           2:薄く2 ( 0,1→0 : 2→1 : 3 →2 )
*           3:濃く1 ( 0,1→2 : 2,3→3 )
*           4:濃く2 ( 0→1 : 1→2 : 2,3→3 )
*           5:反転1 ( 0→3 : 1→2 : 2→1 : 3→0 )
*           6:反転2 ( 0,1,2→3 : 3→0 )
*           7:反転3 ( 0→3 : 1,2,3→0 )
*  x    --- 半透明処理開始横座標
*  y    --- 半透明処理開始縦座標
*  w    --- 半透明処理幅
*  h    --- 半透明処理高さ
*-------------------------------------------------------------------
* 戻り値
*  なし
*-------------------------------------------------------------------
* 備考
*  仮想画面の範囲外はクリッピングされます。
*  w,h は正の数で指定して下さい。
*******************************************************************/
void hanToumei( unsigned char type, int x, int y, int w, int h )
{
	int xe=x+w;
	int ye=y+h;
	int xw;
	int xejyo,xecyu;
	unsigned char *p;
	
	//範囲外の時
	if (xe<0 || ye<0 || x>127 || y>87 || w<1 || h<1) return;
	if (xe>128) xe=128;
	if (ye>88) ye=88;
	if (x<0) x=0;
	if (y<0) y=0;
	
	//座標関連変数設定
	p = pceLCDSetBuffer(INVALIDPTR)+(y<<7);
	xw = x;							//横座標開始位置記憶
	xejyo = x+((4-x%4)&3);			//横座標序盤部終了位置
	xecyu = xejyo+(xe-xejyo)/4*4;	//横座標中盤部終了位置
	
	//半透明処理本体
	switch (type) {
		case 1://薄く1( 0,1→0 : 2,3→1 )
			for (;y<ye;y+=1) {
				unsigned long *pl=(unsigned long *)(&p[xejyo]);//横座標中盤部用ポインタ
				
				//横座標序盤部
				for (;x<xejyo;x+=1) {
					if (p[x]<2) {
						p[x]=0;
					} else {
						p[x]=1;
					}
				}
				
				//横座標中盤部
				for (;x<xecyu;x+=4,pl+=1) {
					*pl=(*pl&0x02020202)>>1;
				}
				
				//横座標終盤部
				for (;x<xe;x+=1) {
					if (p[x]<2) {
						p[x]=0;
					} else {
						p[x]=1;
					}
				}
				x=xw;
				p+=128;
			}
			break;
		case 2://薄く2( 0,1→0 : 2→1 : 3 →2 )
			for (;y<ye;y+=1) {
				unsigned long *pl=(unsigned long *)(&p[xejyo]);//横座標中盤部用ポインタ
				
				//横座標序盤部
				for (;x<xejyo;x+=1) {
					if (p[x]>0) p[x]-=1;
				}
				
				//横座標中盤部
				for (;x<xecyu;x+=4,pl+=1) {
					*pl=(*pl^0x01010101)&((*pl&0x01010101)<<1|(*pl&0x02020202)>>1);
				}
				
				//横座標終盤部
				for (;x<xe;x+=1) {
					if (p[x]>0) p[x]-=1;
				}
				x=xw;
				p+=128;
			}
			break;
		case 3://濃く1( 0,1→2 : 2,3→3 )
			for (;y<ye;y+=1) {
				unsigned long *pl=(unsigned long *)(&p[xejyo]);//横座標中盤部用ポインタ
				
				//横座標序盤部
				for (;x<xejyo;x+=1) {
					if (p[x]<2) {
						p[x]=2;
					} else {
						p[x]=3;
					}
				}
				
				//横座標中盤部
				for (;x<xecyu;x+=4,pl+=1) {
					*pl=0x02020202|((*pl&0x02020202)>>1);
				}
				
				//横座標終盤部
				for (;x<xe;x+=1) {
					if (p[x]<2) {
						p[x]=2;
					} else {
						p[x]=3;
					}
				}
				x=xw;
				p+=128;
			}
			break;
		case 4://濃く2( 0→1 : 1→2 : 2,3→3 )
			for (;y<ye;y+=1) {
				unsigned long *pl=(unsigned long *)(&p[xejyo]);//横座標中盤部用ポインタ
				
				//横座標序盤部
				for (;x<xejyo;x+=1) {
					if (p[x]<3) p[x]+=1;
				}
				
				//横座標中盤部
				for (;x<xecyu;x+=4,pl+=1) {
					*pl=(*pl^0x01010101)|((*pl&0x01010101)<<1)|((*pl&0x02020202)>>1);
				}
				
				//横座標終盤部
				for (;x<xe;x+=1) {
					if (p[x]<3) p[x]+=1;
				}
				x=xw;
				p+=128;
			}
			break;
		case 5://反転1( 0→3 : 1→2 : 2→1 : 3→0 )
			for (;y<ye;y+=1) {
				unsigned long *pl=(unsigned long *)(&p[xejyo]);//横座標中盤部用ポインタ
				
				//横座標序盤部
				for (;x<xejyo;x+=1) {
					p[x]^=3;
				}
				
				//横座標中盤部
				for (;x<xecyu;x+=4,pl+=1) {
					*pl^=0x03030303;
				}
				
				//横座標終盤部
				for (;x<xe;x+=1) {
					p[x]^=3;
				}
				x=xw;
				p+=128;
			}
			break;
		case 6://反転2( 0,1,2→3 : 3→0 )
			for (;y<ye;y+=1) {
				unsigned long *pl=(unsigned long *)(&p[xejyo]);
				
				//横座標序盤部
				for (;x<xejyo;x+=1) {
					if (p[x]==3) {
						p[x]=0;
					} else {
						p[x]=3;
					}
				}
				
				//横座標中盤部
				for (;x<xecyu;x+=4,pl+=1) {
					*pl=(*pl&0x01010101&(*pl&0x02020202)>>1)^0x01010101;
					*pl|=*pl<<1;
				}
				
				//横座標終盤部
				for (;x<xe;x+=1) {
					if (p[x]==3) {
						p[x]=0;
					} else {
						p[x]=3;
					}
				}
				x=xw;
				p+=128;
			}
			break;
		case 7://反転3( 0→3 : 1,2,3→0 )
			for (;y<ye;y+=1) {
				unsigned long *pl=(unsigned long *)(&p[xejyo]);
				
				//横座標序盤部
				for (;x<xejyo;x+=1) {
					if (p[x]) {
						p[x]=0;
					} else {
						p[x]=3;
					}
				}
				
				//横座標中盤部
				for (;x<xecyu;x+=4,pl+=1) {
					*pl=((*pl&0x01010101)|((*pl&0x02020202)>>1))^0x01010101;
					*pl|=*pl<<1;
				}
				
				//横座標終盤部
				for (;x<xe;x+=1) {
					if (p[x]) {
						p[x]=0;
					} else {
						p[x]=3;
					}
				}
				x=xw;
				p+=128;
			}
			break;
	}
}
